<style>
  .tabs { display: flex; gap: 0; margin-bottom: 12px; border-bottom: 1px solid #e5e7eb; }
  .tab { padding: 8px 16px; background: none; border: none; cursor: pointer; font-size: 13px; color: #6b7280; }
  .tab.active { color: #111; font-weight: 600; border-bottom: 2px solid #111; margin-bottom: -1px; }
  .tab:hover:not(.active) { color: #374151; }
</style>
<h2>Figma to HTML</h2>
<p>Select an auto-layout frame, then export.</p>
<div class="tabs">
  <button class="tab active" data-format="html">HTML + CSS</button>
  <button class="tab" data-format="react">React</button>
</div>
<button id="export">Export</button>
<button id="download-zip">Download ZIP</button>
<button id="cancel">Cancel</button>

<h3 id="output-label">HTML</h3>
<textarea id="output" rows="10" style="width: 100%"></textarea>

<h3>CSS</h3>
<textarea id="css" rows="10" style="width: 100%"></textarea>

<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
<script>
  let exportFormat = 'html';

  document.querySelectorAll('.tab').forEach((tab) => {
    tab.onclick = () => {
      document.querySelectorAll('.tab').forEach((t) => t.classList.remove('active'));
      tab.classList.add('active');
      exportFormat = tab.dataset.format;
      document.getElementById('output-label').textContent = exportFormat === 'react' ? 'JSX' : 'HTML';
    };
  });

  document.getElementById('export').onclick = () => {
    parent.postMessage({ pluginMessage: { type: 'export', format: exportFormat } }, '*');
  };

  document.getElementById('cancel').onclick = () => {
    parent.postMessage({ pluginMessage: { type: 'cancel' } }, '*');
  };

  document.getElementById('download-zip').onclick = () => {
    const output = document.getElementById('output').value;
    const css = document.getElementById('css').value;
    if (!output || !css) {
      alert('Export first to download.');
      return;
    }
    const zip = new JSZip();
    if (exportFormat === 'react') {
      zip.file('Component.jsx', output);
    } else {
      zip.file('index.html', output);
    }
    zip.file('styles.css', css);
    zip.generateAsync({ type: 'blob' }).then((blob) => {
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'figma-export.zip';
      a.click();
      URL.revokeObjectURL(url);
    });
  };

  onmessage = (event) => {
    const msg = event.data?.pluginMessage;
    if (!msg || !msg.type) return;
    if (msg.type === 'export-result') {
      const content = msg.jsx != null ? msg.jsx : msg.html;
      const receivedFormat = msg.format || (msg.jsx != null ? 'react' : 'html');
      document.getElementById('output').value = content || '';
      document.getElementById('css').value = msg.css || '';
      if (msg.format != null || msg.jsx != null) {
        exportFormat = receivedFormat;
        document.querySelectorAll('.tab').forEach((t) => {
          t.classList.toggle('active', t.dataset.format === receivedFormat);
        });
      }
      document.getElementById('output-label').textContent = exportFormat === 'react' ? 'JSX' : 'HTML';
    }
    if (msg.type === 'error') {
      alert(msg.message);
    }
  };
</script>
